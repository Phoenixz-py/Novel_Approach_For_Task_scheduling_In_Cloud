# -*- coding: utf-8 -*-
"""newfcfs.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1attSuw-CarqHyCT0Gpt6wBLRXckl7LLv
"""

import random
import matplotlib.pyplot as plt

class Task:
    def __init__(self, task_id, execution_time):
        self.task_id = task_id
        self.execution_time = execution_time
    def __str__(self):
        return "Task " + str(self.task_id)

    def __repr__(self):
        return "Task " + str(self.task_id)

class VM:
    def __init__(self, vm_id, mips):
        self.vm_id = vm_id
        self.mips = mips
    def __str__(self):
        return "VM " + str(self.vm_id)

    def __repr__(self):
        return "VM " + str(self.vm_id)

def generate_random_tasks_and_vms(num_tasks, num_vms):
    tasks = [Task(task_id, random.randint(5000, 8000)) for task_id in range(num_tasks)]
    vms = [VM(vm_id, random.randint(3000, 6000)) for vm_id in range(num_vms)]
    # print("Generated Tasks:")
    # for task in tasks:
    #     print(f"Task {task.task_id}: Execution Time = {task.execution_time}")

    # # Print the generated VMs
    # print("\nGenerated VMs:")
    # for vm in vms:
    #     print(f"VM {vm.vm_id}: MIPS = {vm.mips}")
    return tasks, vms

def calculate_makespan_fcfs(vms, tasks):
    total_time = 0
    vm_completion_times = [0] * len(vms)

    for task in tasks:
        # Create a list of available VMs for the current task, including their completion times
        available_vms = [(vm, vm_completion_times[vm.vm_id]) for vm in  vms]

        # Sort available VMs based on completion times
        available_vms.sort(key=lambda x: x[1])
        vm, completion_time = available_vms[0]

        execution_time = task.execution_time / vm.mips
       # print(f"{task} assigned to {vm}")
        # Update VM completion time
        vm_completion_times[vm.vm_id] += execution_time

        # Update total_time if necessary
        total_time = max(total_time, vm_completion_times[vm.vm_id])

    return total_time

t1 = Task(0,1000)
t2 = Task(1,2000)
t3 = Task(2,3000)

tasks = [t1,t2,t3]
v1 = VM(0,1000)
v2 = VM(1,2000)
vms = [v1,v2]

print(calculate_makespan_fcfs(vms,tasks))

num_tasks = 2000
num_vms = [100,150,200,250]
maxvm = 250
makespan_history =[]

tasks, vms = generate_random_tasks_and_vms(num_tasks, maxvm)
for i in range(len(num_vms)):
  makespan = calculate_makespan_fcfs(vms[:num_vms[i]+1], tasks)
  makespan_history.append((num_vms[i],makespan))
  print(f"Total Makespan: {makespan:.2f} seconds for {num_vms[i]} VMs and {num_tasks}")

print(makespan_history)

num_tasks = [1000,2000,3000,4000]
num_vms = 200
maxtask = 4000
makespan_history1 =[]

tasks, vms = generate_random_tasks_and_vms(maxtask, num_vms)
for i in range(len(num_tasks)):
  makespan1 = calculate_makespan_fcfs(vms, tasks[:num_tasks[i]+1])
  makespan_history1.append((num_tasks[i],makespan1))
  print(f"Total Makespan: {makespan:.2f} seconds for {num_vms} VMs and {num_tasks[i]}")

print(makespan_history1)

x_values, y_values = zip(*makespan_history)
plt.figure(figsize=(8, 6))  # Optional: Adjust the figure size
plt.plot(x_values, y_values, marker='o', linestyle='-')
plt.title('Makespan Improvement with Increase in Number of VMs')
plt.xlabel('VMs')
plt.ylabel('MakeSpan')
plt.grid(True)  # Optional: Add gridlines
plt.show()

x_values, y_values = zip(*makespan_history1)
plt.figure(figsize=(8, 6))  # Optional: Adjust the figure size
plt.plot(x_values, y_values, marker='o', linestyle='-')
plt.title('Makespan Improvement with Increase in Number of VMs')
plt.xlabel('VMs')
plt.ylabel('MakeSpan')
plt.grid(True)  # Optional: Add gridlines
plt.show()